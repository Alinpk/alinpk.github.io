<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Unarchives on Alan&#39;s tiny world</title>
        <link>https://example.com/categories/unarchives/</link>
        <description>Recent content in Unarchives on Alan&#39;s tiny world</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Alan</copyright><atom:link href="https://example.com/categories/unarchives/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>note</title>
        <link>https://example.com/p/note/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/note/</guid>
        <description>&lt;h2 id=&#34;working-note&#34;&gt;working note
&lt;/h2&gt;&lt;h4 id=&#34;__stdcall&#34;&gt;__stdcall
&lt;/h4&gt;&lt;p&gt;1.definition&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;__stdcall 调用约定用于调用 Win32 API 函数。 被调用方将清理堆栈，以便让编译器生成 vararg 函数 __cdecl。 使用此调用约定的函数需要一个函数原型。 __stdcall 修饰符是 Microsoft 专用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.why&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先感受一下两种风格的效果&lt;/p&gt;
&lt;/blockquote&gt;
 &lt;p&gt;传统上的约定应该是__cdecl，这个约定是函数传递的参数，应该由调用方去清理，从汇编角度看，类似于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* example of __cdecl */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;push arg1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;push arg2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;push arg3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;call function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;add esp,12    ; effectively &amp;#34;pop; pop; pop&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt; &lt;p&gt;__stdcall的约定风格是在Win32 API函数的标准约定，做法如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* example of __stdcall */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;push arg1 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;push arg2 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;push arg3 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;call function // no stack cleanup - callee does this
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;这样就有比较只管的感受了，从汇编码的角度来说，__stdcall把清理的职责归属到了callee，这样在大型项目中，可能会编译出更小的可执行程序。 另一方面，如果使用过C风格的变长参数便可以，虽然我们在语义层面上可以用类似于&lt;code&gt;argc&lt;/code&gt;,&lt;code&gt;argv&lt;/code&gt;的模式去明确参数的数量规则，但编译器层面去统一的约束这点是很困难的，所以__stdcall是不支持这种风格的边长参数的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;这里给出win32流行的一些调用约定（实际跨平台项目我们一般会在非win环境定义对应的空白宏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;__stdcall, 以相反的顺序（从右到左）将参数压入堆栈&lt;/li&gt;
&lt;li&gt;__cdecl, 以相反的顺序（从右到左）将参数压入堆栈&lt;/li&gt;
&lt;li&gt;__clrcall, 按顺序（从左到右）将参数加载到 CLR 表达式堆栈中。&lt;/li&gt;
&lt;li&gt;__fastcall, 存储在寄存器中，然后压入堆栈&lt;/li&gt;
&lt;li&gt;__thiscall, 入栈；此指针存储在 ECX 中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;__attribute__&#34;&gt;&lt;strong&gt;attribute&lt;/strong&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;visibility(default)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以用来定义一些符号是不是可见，可以用来发布api&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
